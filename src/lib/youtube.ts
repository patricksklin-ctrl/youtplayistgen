import { google, youtube_v3 } from "googleapis";
import type { VideoResult, SearchCriteria } from "@/types";

const youtube = google.youtube("v3");

function getPublishedAfterDate(recency: SearchCriteria["recency"]): string {
  const now = new Date();
  switch (recency.unit) {
    case "days":
      now.setDate(now.getDate() - recency.value);
      break;
    case "weeks":
      now.setDate(now.getDate() - recency.value * 7);
      break;
    case "months":
      now.setMonth(now.getMonth() - recency.value);
      break;
  }
  return now.toISOString();
}

function parseDuration(duration: string): number {
  // Parse ISO 8601 duration (e.g., PT1H30M15S)
  const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (!match) return 0;

  const hours = parseInt(match[1] || "0", 10);
  const minutes = parseInt(match[2] || "0", 10);
  const seconds = parseInt(match[3] || "0", 10);

  return hours * 3600 + minutes * 60 + seconds;
}

function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${secs.toString().padStart(2, "0")}`;
}

export async function searchVideos(
  criteria: SearchCriteria,
  apiKey: string
): Promise<string[]> {
  const publishedAfter = getPublishedAfterDate(criteria.recency);

  const response = await youtube.search.list({
    key: apiKey,
    part: ["snippet"],
    q: criteria.keywords,
    type: ["video"],
    maxResults: 50,
    publishedAfter,
    relevanceLanguage: criteria.language,
    order: "relevance",
    videoEmbeddable: "true",
    safeSearch: "moderate",
  });

  const videoIds =
    response.data.items
      ?.map((item) => item.id?.videoId)
      .filter((id): id is string => !!id) ?? [];

  return videoIds;
}

export async function getVideoDetails(
  videoIds: string[],
  apiKey: string
): Promise<VideoResult[]> {
  if (videoIds.length === 0) return [];

  // Batch up to 50 video IDs per request
  const batches: string[][] = [];
  for (let i = 0; i < videoIds.length; i += 50) {
    batches.push(videoIds.slice(i, i + 50));
  }

  const results: VideoResult[] = [];

  for (const batch of batches) {
    const response = await youtube.videos.list({
      key: apiKey,
      part: ["snippet", "statistics", "contentDetails"],
      id: batch,
    });

    const videos =
      response.data.items?.map((item) => {
        const duration = parseDuration(item.contentDetails?.duration ?? "PT0S");
        return {
          id: item.id ?? "",
          title: item.snippet?.title ?? "",
          channelTitle: item.snippet?.channelTitle ?? "",
          thumbnailUrl:
            item.snippet?.thumbnails?.medium?.url ??
            item.snippet?.thumbnails?.default?.url ??
            "",
          publishedAt: item.snippet?.publishedAt ?? "",
          viewCount: parseInt(item.statistics?.viewCount ?? "0", 10),
          duration,
          durationFormatted: formatDuration(duration),
        };
      }) ?? [];

    results.push(...videos);
  }

  return results;
}

export function filterAndSortVideos(
  videos: VideoResult[],
  criteria: SearchCriteria
): VideoResult[] {
  const minDurationSeconds = criteria.duration.min * 60;
  const maxDurationSeconds = criteria.duration.max * 60;

  return videos
    .filter((video) => {
      // Filter by minimum views
      if (video.viewCount < criteria.minViews) return false;

      // Filter by duration range
      if (video.duration < minDurationSeconds) return false;
      if (video.duration > maxDurationSeconds) return false;

      return true;
    })
    .sort((a, b) => b.viewCount - a.viewCount); // Sort by views descending
}

export function selectVideosForTarget(
  videos: VideoResult[],
  target: SearchCriteria["target"]
): VideoResult[] {
  const selected: VideoResult[] = [];
  let totalSeconds = 0;

  for (const video of videos) {
    if (target.type === "videos" && selected.length >= target.value) {
      break;
    }
    if (target.type === "minutes" && totalSeconds >= target.value * 60) {
      break;
    }

    selected.push(video);
    totalSeconds += video.duration;
  }

  return selected;
}

export async function createPlaylist(
  title: string,
  privacy: "public" | "unlisted" | "private",
  accessToken: string
): Promise<{ id: string; url: string }> {
  const oauth2Client = new google.auth.OAuth2();
  oauth2Client.setCredentials({ access_token: accessToken });

  const response = await youtube.playlists.insert({
    auth: oauth2Client,
    part: ["snippet", "status"],
    requestBody: {
      snippet: {
        title,
        description: "Generated by YouTube Playlist Generator",
      },
      status: {
        privacyStatus: privacy,
      },
    },
  });

  const playlistId = response.data.id ?? "";
  return {
    id: playlistId,
    url: `https://www.youtube.com/playlist?list=${playlistId}`,
  };
}

export async function addVideoToPlaylist(
  playlistId: string,
  videoId: string,
  accessToken: string
): Promise<void> {
  const oauth2Client = new google.auth.OAuth2();
  oauth2Client.setCredentials({ access_token: accessToken });

  await youtube.playlistItems.insert({
    auth: oauth2Client,
    part: ["snippet"],
    requestBody: {
      snippet: {
        playlistId,
        resourceId: {
          kind: "youtube#video",
          videoId,
        },
      },
    },
  });
}
